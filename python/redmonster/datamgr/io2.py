# Write output files after running entirety of redmonster
#
# Tim Hutchinson, University of Utah, August 2014
#
# Edited to reflect changes made to zfitter and zpicker, July 2015
# t.hutchinson@utah.edu


import re
from os import environ, makedirs, getcwd, remove
from os.path import exists, join, basename
from time import gmtime, strftime

import numpy as n
from astropy.io import fits
from glob import iglob

from redmonster._version import __version__


def read_ndArch(fname):
    """
        Read in an ndArch archetype file, parsing parameter baselines.
        (See ndArch data model document for file details.)
        
        Written by A. Bolton, U. of Utah (at IAC), May 2014
        
        Returns the tuple:
        (data, baselines, infodict)
        
        where
        
        data is an array containing archetype templates with
        shape (N_0, N_1,...,N_(npar-1),N_wave)
        
        baselines is a list containing the parameter baseline
        vectors along each of the parameter axes as numpy arrays
        
        infodict is a dictionary with the following keys:
        'filename': archetype source filename (w/o path)
        'class': archetype class taken from filename
        'version': archetype version taken from filename
        'coeff0': log10 Angstroms of the zeroth wavelength pixel
        'coeff1': delta-log10-Angstrom gridding in wavelength
        'nwave': number of pixels in the wavelength dimension
        'fluxunit': unit of archetype fluxes, if specified in file
        'par_names': names of parameter axes, if specified in file
        'par_units': units of parameter axes, if specified in file
        'par_axistype': baseline specification for each axis, from:
        'regular' (regular numerical gridding)
        'irregular' (irregular numerical gridding)
        'labeled' (string-labeled physical parameter gridding)
        'named' (arbitrary string-named objects)
        'index' (one-based index: default if no other spec)
        """
    # Test file generated by test_ndArch.py:
    # fname = 'ndArch-TEST-v00.fits'
    # Parse class and version from the filename:
    fn_ROOT = fname[:fname.rfind('.fits')]
    fn_CLASS = fn_ROOT.split('-')[-2]
    fn_VERSION = fn_ROOT.split('-')[-1]
    # Get the data and header:
    data = fits.getdata(fname).copy()
    header = fits.getheader(fname)
    # Identify how many parameters:
    npars = len(data.shape) - 1
    emptyparlist = ['']
    # Initialize output info dictionary:
    infodict = {'filename': fname.split('/')[-1],
        'class': fn_CLASS,
        'version': fn_VERSION,
        'coeff0': header['CRVAL1'],
        'coeff1': header['CDELT1'],
        'nwave': header['NAXIS1'],
        'fluxunit': '',
        'par_names': ['']*npars,
        'par_units': ['']*npars,
        'par_axistype': ['index']*npars}
    if ('BUNIT' in header): infodict['fluxunit'] = header['BUNIT']
    # Initialize list of baselines with index defaults:
    baselines = [n.arange(this_size)+1 for this_size in data.shape[:-1]]
    # Loop over parameters and construct baselines:
    for ipar in range(npars):
        # Translate Python axis index integer to FITS axis index string:
        ax = str(npars + 1 - ipar)
        # Populate name & units for this axis, if available:
        if ('CNAME'+ax in header):
            infodict['par_names'][ipar] = header['CNAME'+ax]
        if ('CUNIT'+ax in header):
            infodict['par_units'][ipar] = header['CUNIT'+ax]
        # The axis condition tests -- maybe inefficient to always compute
        # all of these, but makes for nicer code:
        is_regular = (('CRPIX'+ax in header) and ('CRVAL'+ax in header) and
                      ('CDELT'+ax in header))
        pv_base = ['PV'+ax+'_'+str(j+1) for j in range(data.shape[ipar])]
        pv_test = n.asarray([this_pv in header for this_pv in pv_base])
        is_irregular = pv_test.prod() > 0
        ps_base = ['PS'+ax+'_'+str(j+1) for j in range(data.shape[ipar])]
        ps_test = n.asarray([this_ps in header for this_ps in ps_base])
        is_labeled = ps_test.prod() > 0
        n_base = ['N'+ax+'_'+str(j+1) for j in range(data.shape[ipar])]
        n_test = n.asarray([this_n in header for this_n in n_base])
        is_named = n_test.prod() > 0
        if is_regular:
            baselines[ipar] = ((n.arange(data.shape[ipar]) + 1 -
                                header['CRPIX'+ax]) * header['CDELT'+ax] +
                               header['CRVAL'+ax])
            infodict['par_axistype'][ipar] = 'regular'
        elif is_irregular:
            baselines[ipar] = n.asarray([header[this_pv] for this_pv in
                                         pv_base])
            infodict['par_axistype'][ipar] = 'irregular'
        elif is_labeled:
            baselines[ipar] = n.asarray([header[this_ps] for this_ps in
                                         ps_base])
            infodict['par_axistype'][ipar] = 'labeled'
        elif is_named:
            baselines[ipar] = n.asarray([header[this_n] for this_n in n_base])
            infodict['par_axistype'][ipar] = 'named'
    return data, baselines, infodict

# write_ndArch.py
#
# Code for writing ndArch files
#
# bolton@utah@iac 2014mayo
#

def write_ndArch(data, baselines, infodict):
    """
        Write archetype spectrum grid data to and ndArch file.
        (See ndArch data model document for file details.)
        
        Written by A. Bolton, U. of Utah (at IAC), May 2014
        
        Arguments are as follows:
        
        data is an array containing archetype templates with
        shape (N_0, N_1,...,N_(npar-1),N_wave)
        
        baselines is a list containing the parameter baseline
        arrays along each of the parameter axes.
        
        infodict is a dictionary with the following REQUIRED keys:
        'filename': archetype output filename (WITH path, as needed!!);
        to conform, must be of the form ndArch-CLASS-VERSION.fits
        'coeff0': log10 Angstroms of the zeroth wavelength pixel
        'coeff1': delta-log10-Angstrom gridding in wavelength
        'par_axistype': baseline specification for each axis, from:
            'regular' (regular numerical gridding)
            'irregular' (irregular numerical gridding)
            'labeled' (string-labeled physical parameter gridding)
            'named' (arbitrary string-named objects)
            'index' (one-based index; default -- need not be explicit)
        
        infodict can also have the following OPTIONAL keywords:
        'fluxunit': unit of archetype fluxes (string)
        'par_names': names of parameter axes (array of strings)
        'par_units': units of parameter axes (array of strings)
        
        *Note* that the 'infodict' entries are all the same as in
        read_ndArch, EXCEPT for 'filename', which behaves slightly
        differently in that it is to include the path for write_ndArch,
        but strips the path for read_ndArch.
        """
    # Initialize the HDU:
    hdu = fits.PrimaryHDU(data)
    # Set the flux units, if they are provided:
    if ('fluxunit' in infodict):
        hdu.header.set('BUNIT', value=infodict['fluxunit'], comment='Data unit')
    # Work out the number of parameters:
    npars = len(data.shape) - 1
    # Set the keywords for the wavelength baseline:
    hdu.header.set('CNAME1', value='loglam', comment='Axis 1 name')
    hdu.header.set('CUNIT1', value='log10(Angstroms)', comment='Axis 1 unit')
    hdu.header.set('CRPIX1', value=1., comment='Axis 1 reference pixel')
    hdu.header.set('CRVAL1', value=infodict['coeff0'],
                   comment='Axis 1 reference value')
    hdu.header.set('CDELT1', value=infodict['coeff1'],
                   comment='Axis 1 increment')
    # Loop over parameters...
    # Reverse ordering is to get things in FITS header in natural order.
    for ipar in range(npars)[::-1]:
        # Translate Python axis index integer to FITS axis index string:
        ax = str(npars + 1 - ipar)
        # Populate name & units for this axis, if available:
        if ('par_names' in infodict):
            hdu.header.set('CNAME'+ax, value=infodict['par_names'][ipar],
                           comment='Axis ' + ax + ' name')
        if ('par_units' in infodict):
            hdu.header.set('CUNIT'+ax, value=infodict['par_units'][ipar],
                           comment='Axis ' + ax + ' unit')
        if (infodict['par_axistype'][ipar].strip() == 'regular'):
            hdu.header.set('CRPIX'+ax, value=1.0,
                           comment='Axis '+ax+' reference pixel')
            hdu.header.set('CRVAL'+ax, value=baselines[ipar][0],
                           comment='Axis '+ax+' reference value')
            hdu.header.set('CDELT'+ax,
                           value=(baselines[ipar][1]-baselines[ipar][0]),
                           comment='Axis '+ax+' increment')
        elif (infodict['par_axistype'][ipar].strip() == 'irregular'):
            pv_base = ['PV'+ax+'_'+str(j+1) for j in range(data.shape[ipar])]
            for j in range(data.shape[ipar]):
                hdu.header.set(pv_base[j], value=baselines[ipar][j],
                               comment='Axis '+ax+' value at pixel ' + str(j+1))
        elif (infodict['par_axistype'][ipar].strip() == 'labeled'):
            ps_base = ['PS'+ax+'_'+str(j+1) for j in range(data.shape[ipar])]
            for j in range(data.shape[ipar]):
                hdu.header.set(ps_base[j], value=baselines[ipar][j],
                               comment='Axis '+ax+' label at pixel ' + str(j+1))
        elif (infodict['par_axistype'][ipar].strip() == 'named'):
            n_base = ['N'+ax+'_'+str(j+1) for j in range(data.shape[ipar])]
            for j in range(data.shape[ipar]):
                hdu.header.set(n_base[j], value=baselines[ipar][j],
                               comment='Axis '+ax+' name at pixel ' + str(j+1))
        else:
            pass
    hdu.writeto(infodict['filename'], clobber=True)


class WriteRedmonster:
    '''
        Class to write output file at the end of running redmonster.
        
        The zpick argument is simply the entire object created by
        running redmonster.physics.zpicker.py . The self.dest argument is
        a string containing the path in which to save the output file.
        
        If no dest argument is given, or the path does not exist, then
        the write_rm() method will default to writing in
        $REDMONSTER_SPECTRO_REDUX/$RUN2D/pppp/$RUN1D/ . If the necessary
        environmental variables are also not specified, it will write in
        the directory in which it is being run.
        
        The default behavior is to not clobber any older version of the
        output file in the given directory.  Setting clobber=True will
        overwrite old versions of the output file.
        '''
    def __init__(self, zpick, dest=None, clobber=True):
        self.clobber = clobber
        self.zpick = zpick
        #if dest and exists(dest): self.dest = dest
        if dest is not None:
            if exists(dest):
                self.dest = dest
            else:
                try:
                    makedirs(dest)
                    self.dest = dest
                except Exception as e:
                    self.dest = None
                    print("Exception: %r" % e)
        else:
            bsr = environ['REDMONSTER_SPECTRO_REDUX']
            run2d = environ['RUN2D']
            run1d = environ['RUN1D']
            if bsr and run2d and run1d:
                testpath = join(bsr, run2d, '%s'%
                                __version__.replace('.', '_'), '%s' %
                                zpick.plate)
                if exists(testpath):
                    self.dest = testpath
                else:
                    try:
                        makedirs(testpath)
                        self.dest = testpath
                    except Exception as e:
                        self.dest = None
                        print("Exception: %r" % e)
            else: self.dest = None

    def create_hdulist(self):
        # Get old header, append new stuff
        try:
            hdr = self.zpick.hdr
        except AttributeError:
            hdr = fits.Header()
        try:
            hdr.remove('HUMIDITY')
        except KeyError:
            pass
        try:
            hdr.remove('DUSTA')
        except KeyError:
            pass
        try:
            hdr.remove('DUSTB')
        except KeyError:
            pass
        hdr.extend([('SPEC2D',environ['RUN2D'],
                     'Version of spec2d reductions used'),
                    ('VERS_RM',__version__,'Version of redmonster used'),
                    ('DATE_RM',strftime("%Y-%m-%d_%H:%M:%S", gmtime()),
                     'Time of redmonster completion'),
                    ('NFIBERS', len(self.zpick.z), 'Number of fibers'),
                    ('NZ', len(self.zpick.z[0]),'Number of redshifts retained'),
                    ('RCHI2TH',self.zpick.rchi2threshold,
                     'Reduced chi**2 threshold used')])
        prihdu = fits.PrimaryHDU(header=hdr)
        # Columns for 1st BIN table
        colslist = []
        colslist.append( fits.Column(name='FIBERID', format='J',
                                     array=self.zpick.fiberid) )
        colslist.append( fits.Column(name='DOF', format='J',
                                     array=self.zpick.dof) )
        if hasattr(self.zpick, 'boss_target1'):
            colslist.append( fits.Column(name='BOSS_TARGET1', format='J',
                                         array=self.zpick.boss_target1) )
        if hasattr(self.zpick, 'eboss_target0'):
            colslist.append( fits.Column(name='EBOSS_TARGET0', format='J',
                                         array=self.zpick.eboss_target0) )
        if hasattr(self.zpick, 'eboss_target1'):
            colslist.append( fits.Column(name='EBOSS_TARGET1', format='J',
                                         array=self.zpick.eboss_target1) )
        for i in range(len(self.zpick.z[0])):
            zlist = []
            zerrlist = []
            classlist = []
            subclasslist = []
            minvectorlist = []
            npolylist = []
            fnamelist = []
            grouplist = []
            npixsteplist = []
            minrchi2list = []
            fslist = []
            for j in range(len(self.zpick.z)):
                zlist.append( self.zpick.z[j][i] )
                zerrlist.append( self.zpick.z_err[j][i] )
                classlist.append( self.zpick.type[j][i] )
                subclasslist.append( repr(self.zpick.subtype[j][i]) )
                fnamelist.append( self.zpick.fname[j][i] )
                grouplist.append( self.zpick.group[j][i] )
                minvectorlist.append( repr(self.zpick.minvector[j][i]) )
                npolylist.append( self.zpick.npoly[j][i] )
                npixsteplist.append( self.zpick.npixstep[j][i] )
                minrchi2list.append( self.zpick.minrchi2[j][i] )
                fslist.append( repr(self.zpick.fs[j][i]) )
            colslist.append( fits.Column(name='Z%s' % (i+1), format='E',
                                         array=zlist) )
            colslist.append( fits.Column(name='Z_ERR%s' % (i+1), format='E',
                                         array=zerrlist) )
            colslist.append( fits.Column(name='CLASS%s' % (i+1), format='%iA' %
                                         max(list(map(len,classlist))),
                                         array=classlist) )
            colslist.append( fits.Column(name='SUBCLASS%s' % (i+1), format='%iA'
                                         % max(list(map(len,subclasslist))),
                                         array=subclasslist) )
            colslist.append( fits.Column(name='FNAME%s' % (i+1), format='%iA' %
                                         max(list(map(len,fnamelist))),
                                         array=fnamelist) )
            colslist.append( fits.Column(name='GROUP%s' % (i+1), format='J',
                                         array=grouplist) )
            colslist.append( fits.Column(name='MINVECTOR%s' % (i+1),
                                         format='%iA' %
                                         max(list(map(len,minvectorlist))),
                                         array=minvectorlist) )
            colslist.append( fits.Column(name='MINRCHI2%s' % (i+1), format='E',
                                         array=minrchi2list) )
            colslist.append( fits.Column(name='NPOLY%s' % (i+1), format='J',
                                         array=npolylist) )
            colslist.append( fits.Column(name='NPIXSTEP%s' % (i+1), format='J',
                                         array=npixsteplist) )
            colslist.append( fits.Column(name='THETA%s' % (i+1), format='%iA' %
                                         max(list(map(len,fslist))), array=fslist) )
        colslist.append( fits.Column(name='ZWARNING', format='J',
                                     array=self.zpick.zwarning) )
        colslist.append( fits.Column(name='RCHI2DIFF', format='E',
                                     array=self.zpick.rchi2diff) )
        colslist.append( fits.Column(name='CHI2NULL', format='E',
                                     array=self.zpick.chi2_null) )
        colslist.append( fits.Column(name='SN2DATA', format='E',
                                     array=self.zpick.sn2_data) )
        cols = fits.ColDefs(colslist)
        tbhdu = fits.BinTableHDU.from_columns(cols)
        # ImageHDU of models
        sechdu = fits.ImageHDU(data=self.zpick.models)
        self.thdulist = fits.HDUList([prihdu, tbhdu, sechdu])

    def write_fiber(self):
        self.clobber = True # Temporary fix!!
        self.create_hdulist()
        if self.clobber:
            if self.dest is not None:
                self.thdulist.writeto(join(self.dest, '%s' %
                                           'redmonster-%s-%s-%03d.fits' %
                                           (self.zpick.plate, self.zpick.mjd,
                                            self.zpick.fiberid[0])),
                                      clobber=self.clobber)
                print('Writing redmonster file to %s' % \
                        join(self.dest, '%s' % 'redmonster-%s-%s-%03d.fits' %
                             (self.zpick.plate, self.zpick.mjd,
                              self.zpick.fiberid[0])))
            else:
                self.thdulist.writeto('redmonster-%s-%s-%03d.fits' %
                                      (self.zpick.plate, self.zpick.mjd,
                                       self.zpick.fiberid[0]),
                                      clobber=self.clobber)
                print('Writing redmonster file to %s' % \
                        join( getcwd(), 'redmonster-%s-%s-%03d.fits' %
                             (self.zpick.plate, self.zpick.mjd,
                              self.zpick.fiberid[0]) ) )
        else:
            if self.dest is not None:
                if exists(join(self.dest, '%s' % 'redmonster-%s-%s-%03d.fits' %
                               (self.zpick.plate, self.zpick.mjd,
                                self.zpick.fiberid[0]))):
                    self.thdulist.writeto(join(self.dest, '%s' %
                                               'redmonster-%s-%s-%s-%03d.fits' %
                                               (self.zpick.plate,
                                                self.zpick.mjd,
                                                self.zpick.fiberid[0],
                                                strftime("%Y-%m-%d_%H:%M:%S",
                                                         gmtime()))))
                    print('Writing redmonster file to %s' % \
                            join(self.dest, '%s' %
                                 'redmonster-%s-%s-%s-%03d.fits' %
                                 (self.zpick.plate, self.zpick.mjd,
                                  self.zpick.fiberid[0],
                                  strftime("%Y-%m-%d_%H:%M:%S", gmtime()))))
                else:
                    self.thdulist.writeto(join(self.dest, '%s' %
                                               'redmonster-%s-%s-%03d.fits' %
                                               (self.zpick.plate,
                                                self.zpick.mjd,
                                                self.zpick.fiberid[0])))
                    print('Writing redmonster file to %s' % \
                            join(self.dest, '%s' % 'redmonster-%s-%s-%03d.fits'
                                 % (self.zpick.plate, self.zpick.mjd,
                                    self.zpick.fiberid[0])))
            else:
                if exists('redmonster-%s-%s-%03d.fits' %
                          (self.zpick.plate, self.zpick.mjd,
                           self.zpick.fiberid[0])):
                    self.thdulist.writeto('redmonster-%s-%s-%s-%03d.fits' %
                                          (self.zpick.plate, self.zpick.mjd,
                                           self.zpick.fiberid[0],
                                           strftime("%Y-%m-%d_%H:%M:%S",
                                                    gmtime())))
                    print('Writing redmonster file to %s' % \
                            join( getcwd(), 'redmonster-%s-%s-%s-%03d.fits' %
                                 (self.zpick.plate, self.zpick.mjd,
                                  self.zpick.fiberid[0],
                                  strftime("%Y-%m-%d_%H:%M:%S", gmtime()))))
                else:
                    self.thdulist.writeto('redmonster-%s-%s-%03d.fits' %
                                          (self.zpick.plate, self.zpick.mjd,
                                           self.zpick.fiberid[0]))
                    print('Writing redmonster file to %s' % \
                            join( getcwd(), 'redmonster-%s-%s-%03d.fits' %
                                 (self.zpick.plate, self.zpick.mjd,
                                  self.zpick.fiberid[0])))

    def write_plate(self):
        self.create_hdulist()
        if self.clobber:
            if self.dest is not None:
                self.thdulist.writeto(join(self.dest, '%s' %
                                           'redmonster-%s-%s.fits' %
                                           (self.zpick.plate, self.zpick.mjd)),
                                      clobber=self.clobber)
                print('Writing redmonster file to %s' % \
                        join(self.dest, '%s' % 'redmonster-%s-%s.fits' %
                             (self.zpick.plate, self.zpick.mjd)))
            else:
                self.thdulist.writeto('redmonster-%s-%s.fits' %
                                      (self.zpick.plate, self.zpick.mjd),
                                      clobber=self.clobber)
                print('Writing redmonster file to %s' % \
                        join( getcwd(), 'redmonster-%s-%s.fits' %
                             (self.zpick.plate, self.zpick.mjd) ))
        else:
            if self.dest is not None:
                if exists(join(self.dest, '%s' % 'redmonster-%s-%s.fits' %
                               (self.zpick.plate, self.zpick.mjd))):
                    self.thdulist.writeto(join(self.dest,
                                               '%s' % 'redmonster-%s-%s-%s.fits'
                                               % (self.zpick.plate,
                                                  self.zpick.mjd,
                                                  strftime("%Y-%m-%d_%H:%M:%S",
                                                           gmtime()))))
                    print('Writing redmonster file to %s' % \
                            join(self.dest, '%s' % 'redmonster-%s-%s-%s.fits' %
                                 (self.zpick.plate, self.zpick.mjd,
                                  strftime("%Y-%m-%d_%H:%M:%S", gmtime()))))
                else:
                    self.thdulist.writeto(join(self.dest, '%s' %
                                               'redmonster-%s-%s.fits' %
                                               (self.zpick.plate,
                                                self.zpick.mjd)))
                    print('Writing redmonster file to %s' % \
                            join(self.dest, '%s' % 'redmonster-%s-%s.fits' %
                                 (self.zpick.plate, self.zpick.mjd)))
            else:
                if exists('redmonster-%s-%s.fits' % (self.zpick.plate,
                                                     self.zpick.mjd)):
                    self.thdulist.writeto('redmonster-%s-%s-%s.fits' %
                                          (self.zpick.plate, self.zpick.mjd,
                                           strftime("%Y-%m-%d_%H:%M:%S",
                                                    gmtime())))
                    print('Writing redmonster file to %s' % \
                            join( getcwd(), 'redmonster-%s-%s-%s.fits' %
                                 (self.zpick.plate, self.zpick.mjd,
                                  strftime("%Y-%m-%d_%H:%M:%S", gmtime()))))
                else:
                    self.thdulist.writeto('redmonster-%s-%s.fits' %
                                          (self.zpick.plate, self.zpick.mjd))
                    print('Writing redmonster file to %s' % \
                            join( getcwd(), 'redmonster-%s-%s.fits' %
                                 (self.zpick.plate, self.zpick.mjd)))

# ------------------------------------------------------------------------------

'''Combine individual fiber fits files into a single plate file, orxxxxx
combine all plate files into an spAll-like file to combine fiber files,
create object for a given plate, mjd and call
method merge_fibers() to create spAll-like file,
instantiate with no plate, mjd and call methond merge_plates()
'''

# Tim Hutchinson, University of Utah, November 2014
# t.hutchinson@utah.edu


class MergeRedmonster:
    
    def __init__(self, plate=None, mjd=None, temp=None):
        self.plate = plate
        self.mjd = mjd
        self.temp = temp
    
    def merge_fibers(self):
        self.filepaths = []
        self.type = []
        self.subtype = []
        self.fiberid = []
        self.minvector = []
        self.minrchi2 = []
        self.zwarning = []
        self.dof = []
        self.npoly = []
        self.fname = []
        self.npixstep = []
        self.boss_target1 = []
        self.chi2diff = []
        self.chi2_null = []
        self.sn2_data = []
        self.models = None
        self.hdr = None
        try:
            topdir = environ['REDMONSTER_SPECTRO_REDUX']
        except KeyError as e:
            topdir = None
            print("Enviromental variable 'REDMONSTER_SPECTRO_REDUX' not set: \
                    %r" % e)
        try:
            run2d = environ['RUN2D']
        except KeyError as e:
            run2d = None
            print("Enviromental variable 'RUN2D' not set: %r" % e)
        try:
            run1d = environ['RUN1D']
        except KeyError as e:
            run1d = None
            print("Enviromental variable 'RUN1D' not set: %r" % e)

        fiberdir = join(topdir, run2d, '%s' % __version__.replace('.', '_'), '%s' % self.plate,
                        'redmonster-%s-%s-*.fits' % (self.plate, self.mjd)) if \
                               topdir and run2d and run1d else None
        if fiberdir:
            for path in iglob(fiberdir):
                self.filepaths.append(path)
                fiberfile = basename(path)
                self.fiberid.append( int(fiberfile[22:25]) )
            self.z = n.zeros( (len(self.fiberid),5) )
            self.z_err = n.zeros( self.z.shape )
            try: self.hdr = fits.open( join( environ['BOSS_SPECTRO_REDUX'],
                                            environ['RUN2D'], '%s' % self.plate,
                                            'spPlate-%s-%s.fits' %
                                            (self.plate,self.mjd) ) )[0].header
            except Exception as e:
                self.hdr = fits.Header()
                print("Exception: %r" % e)
            npix = fits.open( join( environ['BOSS_SPECTRO_REDUX'],
                                   environ['RUN2D'], '%s' % self.plate,
                                   'spPlate-%s-%s.fits' %
                                   (self.plate,self.mjd) ) )[0].data.shape[1]
            #npix = fits.open('/uufs/chpc.utah.edu/common/home/sdss00/ebosswork/eboss/spectro/redux/test/bautista/test_dr14/%s/spPlate-%s-%s.fits' % (self.plate, self.plate, self.mjd)).data.shape[1]
            self.models = n.zeros( (self.z.shape[0],npix) )
            self.filepaths.sort()
            self.fiberid.sort()
            for i, path in enumerate(self.filepaths):
                hdu = fits.open(path)
                self.z[i,0] = hdu[1].data.Z1[0]
                self.z[i,1] = hdu[1].data.Z2[0]
                self.z_err[i,0] = hdu[1].data.Z_ERR1[0]
                self.z_err[i,1] = hdu[1].data.Z_ERR2[0]
                self.type.append(hdu[1].data.CLASS1[0])
                self.subtype.append(hdu[1].data.SUBCLASS1[0])
                self.minvector.append(hdu[1].data.MINVECTOR1[0])
                self.zwarning.append(hdu[1].data.ZWARNING[0])
                self.dof.append(hdu[1].data.DOF[0])
                self.npoly.append(hdu[1].data.NPOLY1[0])
                self.fname.append(hdu[1].data.FNAME1[0])
                self.npixstep.append(hdu[1].data.NPIXSTEP1[0])
                self.chi2diff.append(hdu[1].data.RCHI2DIFF[0])
                try:
                    self.boss_target1.append(hdu[1].data.BOSS_TARGET1[0])
                except AttributeError:
                    pass
                try:
                    self.eboss_target0.append(hdu[1].data.EBOSS_TARGET0[0])
                except AttributeError:
                    pass
                try:
                    self.eboss_target1.append(hdu[1].data.EBOSS_TARGET1[0])
                except AttributeError:
                    pass
                self.models[i] = hdu[2].data[0]
                #remove(path)
                               
            output = WriteRedmonster(self, clobber=True)
            output.write_plate()

    def merge_plates(self):
        self.type = []
        self.subtype = []
        self.fiberid = []
        self.minvector = []
        self.zwarning = []
        self.dof = []
        self.npoly = []
        self.fname = []
        self.npixstep = []
        self.chi2diff = []
        self.boss_target1 = []
        self.eboss_target0 = []
        self.eboss_target1 = []
        self.plates = []
        self.models = n.zeros((1,1))
        self.hdr = fits.Header()
        try:
            topdir = environ['REDMONSTER_SPECTRO_REDUX']
        except KeyError as e:
            topdir = None
            print("Environ variable 'REDMONSTER_SPECTRO_REDUX is not set: %r" %\
                    e)
        try: run2d = environ['RUN2D']
        except KeyError:
            run2d = None
            print("Environmental variable 'RUN2D' is not set: %r" % e)
        try:
            run1d = environ['RUN1D']
        except KeyError:
            run1d = None
            print("Environmental variable 'RUN1D' is not set: %r" % e)
        platedir = join( topdir, run2d, '*') if topdir and run2d else None
        if platedir:
            for path in iglob(platedir):
                self.plates.append( basename(path) )
            self.plates.sort()
            for listitem in self.plates:
                if listitem[-5:] == '.fits': self.plates.remove(listitem)
            self.fiberid = self.plates
            for plate in self.plates:
                print('Merging plate %s' % plate)
                mjds = []
                try:
                    for x in iglob( join( topdir, run2d, '%s' % __version__.replace('.', '_'), '%s' % plate,
                                         'redmonster-%s-*.fits' % plate) ):
                        if basename(x)[16:21] not in mjds:
                            mjds.append(basename(x)[16:21])
                except Exception as e:
                    print("Exception: %r" % e)
                    mjds = None
                if mjds is not [] and mjds is not None:
                    for mjd in mjds:
                        filepath = join( topdir, run2d, '%s' % __version__.replace('.', '_'), str(plate),
                                        'redmonster-%s-%s.fits' % (plate, mjd))
                        if exists(filepath):
                            hdu = fits.open(filepath)
                            self.type += hdu[1].data.CLASS.tolist()
                            self.subtype += hdu[1].data.SUBCLASS.tolist()
                            self.minvector += hdu[1].data.MINVECTOR.tolist()
                            self.zwarning += hdu[1].data.ZWARNING.tolist()
                            self.dof += hdu[1].data.DOF.tolist()
                            self.npoly += hdu[1].data.NPOLY.tolist()
                            self.fname += hdu[1].data.FNAME.tolist()
                            self.npixstep += hdu[1].data.NPIXSTEP.tolist()
                            self.chi2diff += hdu[1].data.CHI2DIFF.tolist()
                            try:
                                self.z1 = n.append(self.z1, hdu[1].data.Z1)
                            except NameError:
                                self.z1 = hdu[1].data.Z1
                            try:
                                self.z_err1 = n.append(self.z_err1,
                                                        hdu[1].data.Z_ERR1)
                            except NameError:
                                self.z_err1 = hdu[1].data.Z_ERR1
                            try:
                                self.z2 = n.append(self.z2, hdu[1].data.Z2)
                            except NameError:
                                self.z2 = hdu[1].data.Z2
                            try:
                                self.z_err2 = n.append(self.z_err2,
                                                        hdu[1].data.Z_ERR2)
                            except NameError:
                                self.z_err2 = hdu[1].data.Z_ERR2
        self.z = n.zeros( (self.z1.shape[0],2) )
        self.z_err = n.zeros( self.z.shape )
        self.z[:,0] = self.z1
        self.z[:,1] = self.z2
        self.z_err[:,0] = self.z_err1
        self.z_err[:,1] = self.z_err2
        
        output = WriteRedmonster(self)
        output.create_hdulist()
        output.thdulist.writeto( join( topdir, run2d, '%s' % __version__.replace('.', '_'), 'redmonsterAll-%s.fits' %
                                      run2d), clobber=True)


    def merge_fibers2(self):
        self.filepaths = []
        self.fiberid = []
        self.dof = []
        self.boss_target1 = []
        self.eboss_target0 = []
        self.eboss_target1 = []
        self.z1 = []
        self.z_err1 = []
        self.class1 = []
        self.subclass1 = []
        self.fname1 = []
        self.group1 = []
        self.minvector1 = []
        self.minrchi21 = []
        self.npoly1 = []
        self.npixstep1 = []
        self.theta1 = []
        self.z2 = []
        self.z_err2 = []
        self.class2 = []
        self.subclass2 = []
        self.fname2 = []
        self.group2 = []
        self.minvector2 = []
        self.minrchi22 = []
        self.npoly2 = []
        self.npixstep2 = []
        self.theta2 = []
        self.z3 = []
        self.z_err3 = []
        self.class3 = []
        self.subclass3 = []
        self.fname3 = []
        self.group3 = []
        self.minvector3 = []
        self.minrchi23 = []
        self.npoly3 = []
        self.npixstep3 = []
        self.theta3 = []
        self.z4 = []
        self.z_err4 = []
        self.class4 = []
        self.subclass4 = []
        self.fname4 = []
        self.group4 = []
        self.minvector4 = []
        self.minrchi24 = []
        self.npoly4 = []
        self.npixstep4 = []
        self.theta4 = []
        self.z5 = []
        self.z_err5 = []
        self.class5 = []
        self.subclass5 = []
        self.fname5 = []
        self.group5 = []
        self.minvector5 = []
        self.minrchi25 = []
        self.npoly5 = []
        self.npixstep5 = []
        self.theta5 = []
        self.zwarning = []
        self.rchi2diff = []
        self.chi2_null = []
        self.sn2_data = []
        try:
            topdir = environ['REDMONSTER_SPECTRO_REDUX']
        except KeyError:
            topdir = None
            print("Environmental variable 'REDMONSTER_SPECTRO_REDUX' is \
            not set: %r" % e)
        try:
            run2d = environ['RUN2D']
        except KeyError:
            run2d = None
            print("Environmental variable 'RUN2D' is not set: %r" % e)
        try:
            run1d = environ['RUN1D']
        except KeyError:
            run1d = None
            print("Environmental variable 'RUN1D' is not set: %r" % e)
        fiberdir = join(topdir, run2d, '%s' % __version__.replace('.', '_'), '%s' % self.plate,
                        'redmonster-%s-%s-*.fits' % (self.plate, self.mjd)) if \
                               topdir and run2d and run1d else None
        
        if fiberdir:
            for path in iglob(fiberdir):
                self.filepaths.append( path )
                fiberfile = basename( path )
                self.fiberid.append( int(fiberfile[22:25])+1 )
            try:
                
                self.hdr = fits.open( join( environ['BOSS_SPECTRO_REDUX'], environ['RUN2D'], '%s' % self.plate, 'spPlate-%s-%s.fits' % (self.plate,self.mjd) ) )[0].header
                
                #self.hdr = fits.open('/uufs/chpc.utah.edu/common/home/sdss00/ebosswork/eboss/spectro/redux/test/bautista/test_dr14/%s/spPlate-%s-%s.fits' % (self.plate, self.plate, self.mjd))[0].header
            except AttributeError:
                self.hdr = fits.Header()
            
            
            npix = fits.open( join( environ['BOSS_SPECTRO_REDUX'],environ['RUN2D'], '%s' % self.plate,'spPlate-%s-%s.fits' %(self.plate,self.mjd) ) )[0].data.shape[1]
            
            #npix = fits.open('/uufs/chpc.utah.edu/common/home/sdss00/ebosswork/eboss/spectro/redux/test/bautista/test_dr14/%s/spPlate-%s-%s.fits' % (self.plate, self.plate, self.mjd))[0].data.shape[1]
            self.models = n.zeros( (len(self.fiberid),5,npix) )
            self.filepaths.sort()
            self.fiberid.sort()
            haveHeader = False
            for i, path in enumerate(self.filepaths):
                hdu = fits.open(path)
                if not haveHeader:
                    self.hdr = hdu[0].header
                    haveHeader = True
                self.dof.append(hdu[1].data.DOF[0])
                self.z1.append(hdu[1].data.Z1[0])
                self.z_err1.append(hdu[1].data.Z_ERR1[0])
                self.class1.append(hdu[1].data.CLASS1[0])
                self.subclass1.append(hdu[1].data.SUBCLASS1[0])
                self.fname1.append(hdu[1].data.FNAME1[0])
                self.group1.append(hdu[1].data.GROUP1[0])
                self.minvector1.append(hdu[1].data.MINVECTOR1[0])
                self.minrchi21.append(hdu[1].data.MINRCHI21[0])
                self.npoly1.append(hdu[1].data.NPOLY1[0])
                self.npixstep1.append(hdu[1].data.NPIXSTEP1[0])
                self.theta1.append(hdu[1].data.THETA1[0])
                self.z2.append(hdu[1].data.Z2[0])
                self.z_err2.append(hdu[1].data.Z_ERR2[0])
                self.class2.append(hdu[1].data.CLASS2[0])
                self.subclass2.append(hdu[1].data.SUBCLASS2[0])
                self.fname2.append(hdu[1].data.FNAME2[0])
                self.group2.append(hdu[1].data.GROUP2[0])
                self.minvector2.append(hdu[1].data.MINVECTOR2[0])
                self.minrchi22.append(hdu[1].data.MINRCHI22[0])
                self.npoly2.append(hdu[1].data.NPOLY2[0])
                self.npixstep2.append(hdu[1].data.NPIXSTEP2[0])
                self.theta2.append(hdu[1].data.THETA2[0])
                self.z3.append(hdu[1].data.Z3[0])
                self.z_err3.append(hdu[1].data.Z_ERR3[0])
                self.class3.append(hdu[1].data.CLASS3[0])
                self.subclass3.append(hdu[1].data.SUBCLASS3[0])
                self.fname3.append(hdu[1].data.FNAME3[0])
                self.group3.append(hdu[1].data.GROUP3[0])
                self.minvector3.append(hdu[1].data.MINVECTOR3[0])
                self.minrchi23.append(hdu[1].data.MINRCHI23[0])
                self.npoly3.append(hdu[1].data.NPOLY3[0])
                self.npixstep3.append(hdu[1].data.NPIXSTEP3[0])
                self.theta3.append(hdu[1].data.THETA3[0])
                self.z4.append(hdu[1].data.Z4[0])
                self.z_err4.append(hdu[1].data.Z_ERR4[0])
                self.class4.append(hdu[1].data.CLASS4[0])
                self.subclass4.append(hdu[1].data.SUBCLASS4[0])
                self.fname4.append(hdu[1].data.FNAME4[0])
                self.group4.append(hdu[1].data.GROUP4[0])
                self.minvector4.append(hdu[1].data.MINVECTOR4[0])
                self.minrchi24.append(hdu[1].data.MINRCHI24[0])
                self.npoly4.append(hdu[1].data.NPOLY4[0])
                self.npixstep4.append(hdu[1].data.NPIXSTEP4[0])
                self.theta4.append(hdu[1].data.THETA4[0])
                self.z5.append(hdu[1].data.Z5[0])
                self.z_err5.append(hdu[1].data.Z_ERR5[0])
                self.class5.append(hdu[1].data.CLASS5[0])
                self.subclass5.append(hdu[1].data.SUBCLASS5[0])
                self.fname5.append(hdu[1].data.FNAME5[0])
                self.group5.append(hdu[1].data.GROUP5[0])
                self.minvector5.append(hdu[1].data.MINVECTOR5[0])
                self.minrchi25.append(hdu[1].data.MINRCHI25[0])
                self.npoly5.append(hdu[1].data.NPOLY5[0])
                self.npixstep5.append(hdu[1].data.NPIXSTEP5[0])
                self.theta5.append(hdu[1].data.THETA5[0])
                self.zwarning.append(hdu[1].data.ZWARNING[0])
                self.rchi2diff.append(hdu[1].data.RCHI2DIFF[0])
                self.chi2_null.append(hdu[1].data.CHI2NULL[0])
                self.sn2_data.append(hdu[1].data.SN2DATA[0])
                try:
                    self.boss_target1.append(hdu[1].data.BOSS_TARGET1[0])
                except (NameError, AttributeError):
                    pass
                try:
                    self.eboss_target0.append(hdu[1].data.EBOSS_TARGET0[0])
                except (NameError, AttributeError):
                    pass
                try:
                    self.eboss_target1.append(hdu[1].data.EBOSS_TARGET1[0])
                except (NameError, AttributeError):
                    pass
                self.models[i] = hdu[2].data[0]
                #remove(path)
            self.hdr['NFIBERS'] = len(self.fiberid)
            prihdu = fits.PrimaryHDU(header=self.hdr)
            colslist = []
            colslist.append( fits.Column(name='FIBERID', format='J',
                                         array=self.fiberid) )
            colslist.append( fits.Column(name='DOF', format='J',
                                         array=self.dof) )
            try: colslist.append( fits.Column(name='BOSS_TARGET1', format='J',
                                              array=self.boss_target1) )
            except (NameError, AttributeError): pass
            try: colslist.append( fits.Column(name='EBOSS_TARGET0', format='J',
                                              array=self.eboss_target0) )
            except (NameError, AttributeError): pass
            try: colslist.append( fits.Column(name='EBOSS_TARGET1', format='J',
                                              array=self.eboss_target1) )
            except (NameError, AttributeError): pass
            colslist.append( fits.Column(name='Z1', format='E', array=self.z1) )
            colslist.append( fits.Column(name='Z_ERR1', format='E',
                                         array=self.z_err1) )
            colslist.append( fits.Column(name='CLASS1', format='%iA' %
                                         max(list(map(len,self.class1))),
                                         array=self.class1) )
            colslist.append( fits.Column(name='SUBCLASS1', format='%iA' %
                                         max(list(map(len,self.subclass1))),
                                         array=self.subclass1) )
            colslist.append( fits.Column(name='FNAME1', format='%iA' %
                                         max(list(map(len,self.fname1))),
                                         array=self.fname1) )
            colslist.append( fits.Column(name='GROUP1', format='J',
                                         array=self.group1) )
            colslist.append( fits.Column(name='MINVECTOR1', format='%iA' %
                                         max(list(map(len,self.minvector1))),
                                         array=self.minvector1) )
            colslist.append( fits.Column(name='MINRCHI21', format='E',
                                         array=self.minrchi21) )
            colslist.append( fits.Column(name='NPOLY1', format='J',
                                         array=self.npoly1) )
            colslist.append( fits.Column(name='NPIXSTEP1', format='J',
                                         array=self.npixstep1) )
            colslist.append( fits.Column(name='THETA1', format='%iA' %
                                         max(list(map(len,self.theta1))),
                                         array=self.theta1) )
            colslist.append( fits.Column(name='Z2', format='E', array=self.z2) )
            colslist.append( fits.Column(name='Z_ERR2', format='E',
                                         array=self.z_err2) )
            colslist.append( fits.Column(name='CLASS2', format='%iA' %
                                         max(list(map(len,self.class2))),
                                         array=self.class2) )
            colslist.append( fits.Column(name='SUBCLASS2', format='%iA' %
                                         max(list(map(len,self.subclass2))),
                                         array=self.subclass2) )
            colslist.append( fits.Column(name='FNAME2', format='%iA' %
                                         max(list(map(len,self.fname2))),
                                         array=self.fname2) )
            colslist.append( fits.Column(name='GROUP2', format='J',
                                         array=self.group2) )
            colslist.append( fits.Column(name='MINVECTOR2', format='%iA' %
                                         max(list(map(len,self.minvector2))),
                                         array=self.minvector2) )
            colslist.append( fits.Column(name='MINRCHI22', format='E',
                                         array=self.minrchi22) )
            colslist.append( fits.Column(name='NPOLY2', format='J',
                                         array=self.npoly2) )
            colslist.append( fits.Column(name='NPIXSTEP2', format='J',
                                         array=self.npixstep2) )
            colslist.append( fits.Column(name='THETA2', format='%iA' %
                                         max(list(map(len,self.theta2))),
                                         array=self.theta2) )
            colslist.append( fits.Column(name='Z3', format='E', array=self.z3) )
            colslist.append( fits.Column(name='Z_ERR3', format='E',
                                         array=self.z_err3) )
            colslist.append( fits.Column(name='CLASS3', format='%iA' %
                                         max(list(map(len,self.class3))),
                                         array=self.class3) )
            colslist.append( fits.Column(name='SUBCLASS3', format='%iA' %
                                         max(list(map(len,self.subclass3))),
                                         array=self.subclass3) )
            colslist.append( fits.Column(name='FNAME3', format='%iA' %
                                         max(list(map(len,self.fname3))),
                                         array=self.fname3) )
            colslist.append( fits.Column(name='GROUP3', format='J',
                                         array=self.group3) )
            colslist.append( fits.Column(name='MINVECTOR3', format='%iA' %
                                         max(list(map(len,self.minvector3))),
                                         array=self.minvector3) )
            colslist.append( fits.Column(name='MINRCHI23', format='E',
                                         array=self.minrchi23) )
            colslist.append( fits.Column(name='NPOLY3', format='J',
                                         array=self.npoly3) )
            colslist.append( fits.Column(name='NPIXSTEP3', format='J',
                                         array=self.npixstep3) )
            colslist.append( fits.Column(name='THETA3', format='%iA' %
                                         max(list(map(len,self.theta3))),
                                         array=self.theta3) )
            colslist.append( fits.Column(name='Z4', format='E', array=self.z4) )
            colslist.append( fits.Column(name='Z_ERR4', format='E',
                                         array=self.z_err4) )
            colslist.append( fits.Column(name='CLASS4', format='%iA' %
                                         max(list(map(len,self.class4))),
                                         array=self.class4) )
            colslist.append( fits.Column(name='SUBCLASS4', format='%iA' %
                                         max(list(map(len,self.subclass4))),
                                         array=self.subclass4) )
            colslist.append( fits.Column(name='FNAME4', format='%iA' %
                                         max(list(map(len,self.fname4))),
                                         array=self.fname4) )
            colslist.append( fits.Column(name='GROUP4', format='J',
                                         array=self.group4) )
            colslist.append( fits.Column(name='MINVECTOR4', format='%iA' %
                                         max(list(map(len,self.minvector4))),
                                         array=self.minvector4) )
            colslist.append( fits.Column(name='MINRCHI24', format='E',
                                         array=self.minrchi24) )
            colslist.append( fits.Column(name='NPOLY4', format='J',
                                         array=self.npoly4) )
            colslist.append( fits.Column(name='NPIXSTEP4', format='J',
                                         array=self.npixstep4) )
            colslist.append( fits.Column(name='THETA4', format='%iA' %
                                         max(list(map(len,self.theta4))),
                                         array=self.theta4) )
            colslist.append( fits.Column(name='Z5', format='E', array=self.z5) )
            colslist.append( fits.Column(name='Z_ERR5', format='E',
                                         array=self.z_err5) )
            colslist.append( fits.Column(name='CLASS5', format='%iA' %
                                         max(list(map(len,self.class5))),
                                         array=self.class5) )
            colslist.append( fits.Column(name='SUBCLASS5', format='%iA' %
                                         max(list(map(len,self.subclass5))),
                                         array=self.subclass5) )
            colslist.append( fits.Column(name='FNAME5', format='%iA' %
                                         max(list(map(len,self.fname5))),
                                         array=self.fname5) )
            colslist.append( fits.Column(name='GROUP5', format='J',
                                         array=self.group5) )
            colslist.append( fits.Column(name='MINVECTOR5', format='%iA' %
                                         max(list(map(len,self.minvector5))),
                                         array=self.minvector5) )
            colslist.append( fits.Column(name='MINRCHI25', format='E',
                                         array=self.minrchi25) )
            colslist.append( fits.Column(name='NPOLY5', format='J',
                                         array=self.npoly5) )
            colslist.append( fits.Column(name='NPIXSTEP5', format='J',
                                         array=self.npixstep5) )
            colslist.append( fits.Column(name='THETA5', format='%iA' %
                                         max(list(map(len,self.theta5))),
                                         array=self.theta5) )
            colslist.append( fits.Column(name='ZWARNING', format='J',
                                         array=self.zwarning) )
            colslist.append( fits.Column(name='RCHI2DIFF', format='E',
                                         array=self.rchi2diff) )
            colslist.append( fits.Column(name='CHI2NULL', format='E',
                                         array=self.chi2_null) )
            colslist.append( fits.Column(name='SN2DATA', format='E',
                                         array=self.sn2_data) )
            cols = fits.ColDefs(colslist)
            tbhdu = fits.BinTableHDU.from_columns(cols)
            # ImageHDU of models
            sechdu = fits.ImageHDU(data=self.models)
            thdulist = fits.HDUList([prihdu, tbhdu, sechdu])
            
            dest = join(topdir, run2d, '%s' % __version__.replace('.', '_'), '%s' % self.plate,
                        'redmonster-%s-%s.fits' % (self.plate, self.mjd))
            thdulist.writeto( dest, clobber=True )

    def merge_plates2(self):
        self.platelist = []
        self.mjdlist = []
        self.fiberid = []
        self.dof = []
        self.boss_target1 = []
        self.eboss_target0 = []
        self.eboss_target1 = []
        self.z = []
        self.z_err = []
        self.type = []
        self.subtype = []
        self.fname = []
        self.minvector = []
        self.minrchi2 = []
        self.npoly = []
        self.npixstep = []
        self.theta = []
        self.zwarning = []
        self.rchi2diff = []
        self.chi2_null = []
        self.sn2_data = []
        self.plates = []
        self.hdr = fits.Header()
        try:
            topdir = environ['REDMONSTER_SPECTRO_REDUX']
        except KeyError:
            topdir = None
            print("Environmental variable 'REDMONSTER_SPECTRO_REDUX' is not \
            set: %r" % e)
        try:
            rmver = environ['REDMONSTER_VER']
        except KeyError:
            rmver = None
            print("Environmental variable 'REDMONSTER_VER' is not set: %r" % e)
        try:
            run2d = environ['RUN2D']
        except KeyError:
            run2d = None
            print("Environmental variable 'RUN2D' is not set: %r" % e)
        try:
            run1d = environ['RUN1D']
        except KeyError:
            run1d = None
            print("Environmental variable 'RUN1D' is not set: %r" % e)
        platedir = join( topdir, run2d, rmver, '*') if topdir and run2d else None
        if platedir:
            for path in iglob(platedir):
                self.plates.append( basename(path) )
            self.plates.sort()
            for listitem in self.plates:
                # Ignore any existing redmonsterAll files
                if listitem[-5:] == '.fits': self.plates.remove(listitem)
            for plate in self.plates:
                print('Merging plate %s' % plate)
                mjds = []
                try:
                    for x in iglob( join( topdir, run2d, rmver, '%s' % plate,
                                         'redmonster-%s-*.fits' % plate) ):
                        if basename(x)[16:21] not in mjds:
                            mjds.append(basename(x)[16:21])
                except Exception as e:
                    mjds = None
                    print("Exception: %r" % e)
                if mjds is not [] and mjds is not None:
                    for mjd in mjds:
                        filepath = join( topdir, run2d, rmver, '%s' % plate,
                                        'redmonster-%s-%s.fits' % (plate, mjd))
                        if exists(filepath):
                            hdu = fits.open(filepath)
                            self.fiberid += hdu[1].data.FIBERID.tolist()
                            self.platelist += [int(plate)] * \
                                    len(hdu[1].data.FIBERID.tolist())
                            self.mjdlist += [int(mjd)] * \
                                    len(hdu[1].data.FIBERID.tolist())
                            self.dof += hdu[1].data.DOF.tolist()
                            try: self.boss_target1 += \
                                        hdu[1].data.BOSS_TARGET1.tolist()
                            except (NameError, AttributeError):
                                pass
                            try:
                                self.eboss_target0 += \
                                        hdu[1].data.EBOSS_TARGET0.tolist()
                            except (NameError, AttributeError):
                                pass
                            try:
                                self.eboss_target1 += \
                                        hdu[1].data.EBOSS_TARGET1.tolist()
                            except (NameError, AttributeError):
                                pass
                            self.z += hdu[1].data.Z1.tolist()
                            self.z_err += hdu[1].data.Z_ERR1.tolist()
                            self.type += hdu[1].data.CLASS1.tolist()
                            self.subtype += hdu[1].data.SUBCLASS1.tolist()
                            self.fname += hdu[1].data.FNAME1.tolist()
                            self.minvector += hdu[1].data.MINVECTOR1.tolist()
                            self.minrchi2 += hdu[1].data.MINRCHI21.tolist()
                            self.npoly += hdu[1].data.NPOLY1.tolist()
                            self.npixstep += hdu[1].data.NPIXSTEP1.tolist()
                            self.theta += hdu[1].data.THETA1.tolist()
                            self.zwarning += hdu[1].data.ZWARNING.tolist()
                            self.rchi2diff += hdu[1].data.RCHI2DIFF.tolist()
                            self.chi2_null += hdu[1].data.CHI2NULL.tolist()
                            self.sn2_data += hdu[1].data.SN2DATA.tolist()
            self.hdr.extend([
                             ('SPEC2D',environ['RUN2D'],
                              'Version of spec2d reductions used'),
                             ('VERS_RM',rmver,'Version of redmonster used'),
                             ('TIME',strftime("%Y-%m-%d_%H:%M:%S", gmtime()),
                              'Time of redmonsterAll creation'),
                             ('NFIBERS', len(self.fiberid), 'Number of fibers'),
                             ('RCHI2TH',0.005,'Reduced chi**2 threshold used')
                             ])
            prihdu = fits.PrimaryHDU(header=self.hdr)
            colslist = []
            colslist.append( fits.Column(name='FIBERID', format='J',
                                         array=self.fiberid) )
            colslist.append( fits.Column(name='PLATE', format='J',
                                         array=self.platelist) )
            colslist.append( fits.Column(name='MJD', format='J',
                                         array=self.mjdlist) )
            colslist.append( fits.Column(name='DOF', format='J',
                                         array=self.dof) )
            try:
                colslist.append( fits.Column(name='BOSS_TARGET1', format='J',
                                              array=self.boss_target1) )
            except (NameError, AttributeError):
                pass
            try:
                colslist.append( fits.Column(name='EBOSS_TARGET0', format='J',
                                              array=self.eboss_target0) )
            except (NameError, AttributeError):
                pass
            try:
                colslist.append( fits.Column(name='EBOSS_TARGET1', format='J',
                                             array=self.eboss_target1) )
            except (NameError, AttributeError):
                pass
            colslist.append( fits.Column(name='Z', format='E', array=self.z) )
            colslist.append( fits.Column(name='Z_ERR', format='E',
                                         array=self.z_err) )
            colslist.append( fits.Column(name='CLASS', format='%iA' %
                                         max(list(map(len,self.type))),
                                         array=self.type) )
            colslist.append( fits.Column(name='SUBCLASS', format='%iA' %
                                         max(list(map(len,self.subtype))),
                                         array=self.subtype) )
            colslist.append( fits.Column(name='FNAME', format='%iA' %
                                         max(list(map(len,self.fname))),
                                         array=self.fname) )
            colslist.append( fits.Column(name='MINVECTOR', format='%iA' %
                                         max(list(map(len,self.minvector))),
                                         array=self.minvector) )
            colslist.append( fits.Column(name='MINRCHI2', format='E',
                                         array=self.minrchi2) )
            colslist.append( fits.Column(name='NPOLY', format='J',
                                         array=self.npoly) )
            colslist.append( fits.Column(name='NPIXSTEP', format='J',
                                         array=self.npixstep) )
            colslist.append( fits.Column(name='THETA', format='%iA' %
                                         max(list(map(len,self.theta))),
                                         array=self.theta) )
            colslist.append( fits.Column(name='ZWARNING', format='J',
                                         array=self.zwarning) )
            colslist.append( fits.Column(name='RCHI2DIFF', format='E',
                                         array=self.rchi2diff) )
            colslist.append( fits.Column(name='CHI2NULL', format='E',
                                         array=self.chi2_null) )
            colslist.append( fits.Column(name='SN2DATA', format='E',
                                         array=self.sn2_data) )
            
            cols = fits.ColDefs(colslist)
            tbhdu = fits.BinTableHDU.from_columns(cols)
            thdulist = fits.HDUList([prihdu, tbhdu])
            
            dest = join(topdir, run2d, rmver, 'redmonsterAll-%s.fits' % run1d)
            thdulist.writeto( dest, clobber=True )

    def merge_chi2(self):
        try:
            topdir = environ['REDMONSTER_SPECTRO_REDUX']
        except KeyError:
            topdir = None
            print("'REDMONSTER_SPECTRO_REDUX' env variable not set.")
        try:
            rmver = environ['REDMONSTER_VER']
        except KeyError:
            rmver = None
            print("Environmental variable 'REDMONSTER_VER' is not set: %r" % e)
        try:
            run2d = environ['RUN2D']
        except KeyError:
            run2d = None
            print("'RUN1D' env variable not set.")
        try:
            run1d = environ['RUN1D']
        except KeyError:
            run1d = None
            print("'RUN1D' env variable not set.")
        chi2path = join( topdir, run2d, rmver, '%s' % self.plate,
                        'chi2arr-%s-%s-%s-*.fits' %
                        (self.temp, self.plate, self.mjd) ) if topdir and \
                                run2d and run1d else None
        
        fiberid = []
        paths = []
        
        if chi2path:
            for file in iglob(chi2path):
                paths.append( file )
                m = re.search( 'chi2arr-%s-%s-%s-(\d+).fits' %
                              (self.temp, self.plate, self.mjd), basename(file))
                if m.group(1): fiberid.append( int(m.group(1)) )
            fiberid.sort()
            paths.sort()
            
            for i,path in enumerate(paths):
                chi2arr = fits.open(path)[0].data
                try:
                    chi2arrs
                except NameError:
                    chi2arrs = n.zeros( (len(fiberid),) + chi2arr.shape[1:] )
                    chi2arrs[i] = chi2arr
                else:
                    chi2arrs[i] = chi2arr
                remove(path)

            prihdu = fits.PrimaryHDU(chi2arrs)
            col1 = fits.Column(name='FIBERID', format='J', array=fiberid)
            cols = fits.ColDefs([col1])
            tbhdu = fits.BinTableHDU.from_columns(cols)
            thdulist = fits.HDUList([prihdu,tbhdu])
            thdulist.writeto( join( topdir, run2d, rmver, '%s' % self.plate,
                                   'chi2arr-%s-%s-%s.fits' %
                                   (self.temp, self.plate, self.mjd) ),
                             clobber=True)


# ------------------------------------------------------------------------------


def write_chi2arr(plate, mjd, fiberid, zchi2arr):
    # Write chi**2 surface, called by zfinder
    prihdu = fits.PrimaryHDU(zchi2arr)
    thdulist = fits.HDUList([prihdu])
    try:
        rsr = environ['REDMONSTER_SPECTRO_REDUX']
        run2d = environ['RUN2D']
        run1d = environ['RUN1D']
        if (rsr is not None) & (run2d is not None) & (run1d is not None):
            testpath = join(rsr, run2d, '%s' % __version__.replace('.', '_'), '%s' % plate)
            if exists(testpath):
                dest = testpath
            else:
                try:
                    makedirs(testpath)
                    dest = testpath
                except Exception as e:
                    print("Exception: %r" % e)
                    dest = None
    except Exception as e:
        print("Exception: %r" % e)
        dest = None
        if dest is not None:
            try:
                thdulist.writeto(join(dest, '%s' % 'chi2arr-%s-%s-%s-%03d.fits'
                                      % (self.type, plate, mjd, fiberid)),
                                 clobber=True)
                print('Writing chi2 file to %s' % \
                        join(dest, '%s' % 'chi2arr-%s-%s-%s-%03d.fits' %
                             (self.type, plate, mjd, fiberid)))
            except Exception as e:
                print('Environment variables not set or path does not exist - \
                        not writing chi2 file! %r' % e)
    else:
        print('Environment variables not set or path does not exist - not \
                writing chi2 file!')


